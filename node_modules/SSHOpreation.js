/**
 * @author Jackie lin
 * @Date 2014-4-1
 * @content deal with the ssh opreation
 */

var Connection = require('ssh2');
var client = require('scp2');
var connect = null;

// default
var _host = 'localhost', _username = '', _password = '', _port = 22, path = '';

exports.getConnection = function() {
    return connect;
};

exports.instance = function() {
    connect = new Connection();
    /**
     * register error, end and close event
     */
    connect.on('error', function(err) {
        console.log('Connection :: error :: ' + err);
    });

    connect.on('end', function() {
        console.log('Connection :: end');
    });

    connect.on('close', function(had_error) {
        console.log('Connection :: close');
    });
};

exports.connection = function() {
    try {
        connect.connect({
            'host': _host,
            'username': _username,
            'port': _port,
            'password': _password
        });
    } catch(e) {
        console.error('connection error!!');
        console.log(e);
    }
};

/**
 * set host configuration
 * ps: when you write test in this file, it should be var args0 = args[0]
 * else it must be args0 = args[0][0]
 */
exports.setHostConfiguration = function() {
    var args = arguments, length = args.length;
    if(length !== 1 && length !== 5) {
        console.error('The host configuration length must be 1 or 4');
        return;
    }
    if(length === 1 && Object.prototype.toString(args[0]).slice(8, -1) === 'Object') {
        var args0 = args[0][0];
        _host = args0.host || _host;
        _username = args0.username || _username;
        _password = args0.password || _password;
        _port = args0.port || _port;
    } else if(length === 4) {
        _host = args[0] || _host;
        _username = args[1] || _username;
        _password = args[2] || _password;
        _port = args[3] || _port;
    }
};

/**
 * register all events and callbacks
 * @param events array
 * @param callbacks functions
 */
exports.registerEvent = function(events, callbacks) {
    if(!events || !callbacks) {
        console.error('events and callbacks must be exists!!');
        return;
    }

    var typeevents = Object.prototype.toString.call(events).slice(8, -1),
        typeCallbacks = Object.prototype.toString.call(callbacks).slice(8, -1),
        i, length;

    if(typeevents === 'String' && typeCallbacks === 'Function') {
        connect.on(events, callbacks);
    } else if(typeevents === 'string' && typeCallbacks === 'Array') {
        for(i = 0, length = callbacks.length; i < length; i++) {
            var t = callbacks[i];
            connect.on(events, t);
        }
    } else if(typeevents === 'Array' && typeCallbacks === 'Array') {
        for(i = 0, length = events.length; i < length; i++) {
            var event = events[i],
                callback = callbacks[i];
            connect.on(event, callback);
        }
    }
};

/**
 * exec command
 * @param command
 * @param callback
 */
exports.executeCommand = function(command, callback) {
    if(!command && !callback) {
        console.error('executeCommand:: command and callback must be exists!!');
        return;
    }

    connect.exec(command, function(err, stream) {
        callback(err, stream);
    });
};

exports.sshEnd = function() {
    if(!connect) {
        return;
    }
    connect.end();
};

exports.mkdir = function(filepath, callback) {
    connect.sftp(function(err, sftp) {
        if(err) {
            console.error('mkdir error: ' + err);
            throw err;
        }

        sftp.on('end', function() {
            console.log('SFTP :: SFTP session closed');
        });


        sftp.mkdir(filepath, callback);
    });
};

exports.setscpDefault = function() {
    client.defaults({
        'port': _port,
        'host': _host,
        'username': _username,
        'password': _password
    });
};

exports.scpmkdir = function(filepath, callback) {
    client.mkdir(filepath, function(err) {
        callback(err);
    });
};

/*exports.scp = function(filepath, hostpath, callback) {
    client.scp(filepath, {
        host: _host,
        username: _username,
        password: _password,
        path: hostpath
    }, function(err) {
        client.close();
        callback(err);
    })
};*/

client.on('end', function() {
    console.log('client is end');
});

exports.scp = function(filepath, hostpath, callback, show) {
    client.scp(filepath, {'path': hostpath}, function(err) {
        // transfer end
        fileLength = 0;
        callback(err);
    });

    var fileLength = 0;
    if(show) {
        client.on('transfer', function(buffer, uploaded, total) {
            fileLength += buffer.length;
            callback(null, fileLength);
        });
    }
};

exports.scpclose = function(callback) {

    client.on('close', function() {
        if(callback) {
            callback();
        }
        console.log('client is close');
    });

    client.close();
};
// test
/*this.setHostConfiguration({'host': '192.168.200.91', 'port': 22, 'username': 'app', 'password': 'app'});

this.setscpDefault();

var that = this;
this.scpmkdir('/home/app/test', function(err) {
    console.log(err);
    that.scp('D:/test', '/home/app/test', function(err, fileLength) {
        console.log(fileLength);
    }, true);
});*/
